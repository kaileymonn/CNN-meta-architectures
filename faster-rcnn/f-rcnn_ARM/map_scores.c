#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "vp_interface.h"

// -------------------------------------------------------------------------------------------------------------------------------------------------- //
// vp_tensor_fix16_t* mapped_scores() takes vp_tensor_float32_t* idx_scores - original 1-D array of scores corresponding to all RPN proposals         // 
//                                          vp_tensor_fix16_t*   rois       - nms output with data array in the following format:                     //  
//                                                                              [bottom-left(x, y), top-right(x, y), class ID, ...]                   //
//                                          vp_tensor_fix16_t*   proposals  - original 1-D array of proposal coordinates and corresponding ID:        //  
//                                                                              [bottom-left(x, y), top-right(x, y), class ID, ...]                   //    
// as arguments, returns a                  vp_tensor_float32_t*            - 1-D array of scores corresponding to each roi generated by nms          //      
// -------------------------------------------------------------------------------------------------------------------------------------------------- //
vp_tensor_float32_output map_scores(vp_tensor_float32_input idx_scores,       
                                vp_tensor_fix16_input rois,               // nms output
                                vp_tensor_fix16_input proposals) {
    // Safety checks
    assert(idx_scores->w >= rois->h);
    int16_t num_rois = rois->h;
    vp_tensor_float32_output mapped_scores = vp_tensor_float32_malloc(1, 1, 1, num_rois);
    for(size_t i = 0; i < num_rois; i++) {
        int16_t counter = 0;
        // Found matching roi
        while(counter <= proposals->h) {
           if(proposals->data[counter*5+0] == rois->data[i*5+0] &&
           proposals->data[counter*5+1] == rois->data[i*5+1] && 
           proposals->data[counter*5+2] == rois->data[i*5+2] &&
           proposals->data[counter*5+3] == rois->data[i*5+3] && 
           proposals->data[counter*5+4] == rois->data[i*5+4]) {
               mapped_scores->data[i] = idx_scores->data[counter];
               break;
           }
           else {
               counter++;
           } 
        }
        // Did not find a match, throw error
        if(counter > proposals->h) {
            perror("Count not find roi in original set of proposals");
            break;
        }   
    }
    return mapped_scores;
}
